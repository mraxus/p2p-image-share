<script>
    const ws = new WebSocket(`ws://${location.host}`);
    const pc = new RTCPeerConnection();
    let dataChannel, remoteId;

    const $ = (id) => document.getElementById(id);
    let receiveBuffer = [];
    let receivedSize = 0;
    let expectedSize = 0;
    let fileName = "";

    const CHUNK_SIZE = 16 * 1024;

    ws.onmessage = async ({ data }) => {
        const msg = JSON.parse(data);
        if (msg.type === 'init') {
            $('myId').textContent = msg.id;
        }

        if (msg.type === 'offer') {
            await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(JSON.stringify({ to: msg.from, type: 'answer', answer }));
        }

        if (msg.type === 'answer') {
            await pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
        }

        if (msg.type === 'candidate') {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
            } catch (e) {
                console.error('Error adding ICE candidate', e);
            }
        }
    };

    pc.onicecandidate = ({ candidate }) => {
        if (candidate && remoteId) {
            ws.send(JSON.stringify({ to: remoteId, type: 'candidate', candidate }));
        }
    };

    pc.ondatachannel = (e) => {
        const channel = e.channel;
        channel.binaryType = 'arraybuffer';

        channel.onmessage = (event) => {
            if (typeof event.data === 'string') {
                const header = JSON.parse(event.data);
                fileName = header.name;
                expectedSize = header.size;
                receiveBuffer = [];
                receivedSize = 0;
                return;
            }

            receiveBuffer.push(event.data);
            receivedSize += event.data.byteLength;

            if (receivedSize === expectedSize) {
                const blob = new Blob(receiveBuffer);
                $('receivedImage').src = URL.createObjectURL(blob);
                receiveBuffer = [];
            }
        };
    };

    $('connect').onclick = async () => {
        remoteId = $('remoteId').value;
        dataChannel = pc.createDataChannel("file");
        dataChannel.binaryType = 'arraybuffer';

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ to: remoteId, type: 'offer', offer }));

        dataChannel.onopen = () => {
            console.log("DataChannel opened");
        };
    };

    $('sendFile').onclick = () => {
        const file = $('fileInput').files[0];
        if (!file || !dataChannel || dataChannel.readyState !== "open") {
            alert("Select a file and ensure connection is ready");
            return;
        }

        // Send metadata first
        const header = JSON.stringify({ name: file.name, size: file.size });
        dataChannel.send(header);

        const reader = new FileReader();
        let offset = 0;

        const readSlice = o => {
            const slice = file.slice(o, o + CHUNK_SIZE);
            reader.readAsArrayBuffer(slice);
        };

        reader.onload = e => {
            dataChannel.send(e.target.result);
            offset += e.target.result.byteLength;

            if (offset < file.size) {
                setTimeout(() => readSlice(offset), 0); // avoid blocking
            } else {
                console.log("File sent completely");
            }
        };

        readSlice(0);
    };
</script>
