<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Sender - P2P Image Share</title>
    <style>
        body { font-family: sans-serif; padding: 1rem; }
        input, button { margin: 0.5rem 0; }
        #log {
            margin-top: 1rem;
            border-top: 1px solid #ccc;
            padding-top: 1rem;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .info { color: #333; }
        .error { color: red; }
        .event { color: green; }
    </style>
</head>
<body>
<h1>Sender</h1>
<p>Your ID: <span id="myId">...</span></p>

<input type="text" id="remoteId" placeholder="Receiver ID">
<button id="connect">Connect</button><br>

<input type="file" id="fileInput">
<button id="sendFile">Send Image</button><br>

<div id="log"></div>

<script>
    const ws = new WebSocket(`ws://${location.host}`);
    const pc = new RTCPeerConnection();
    const CHUNK_SIZE = 16 * 1024;
    let dataChannel, remoteId;
    let remoteDescriptionSet = false;

    const $ = id => document.getElementById(id);

    function log(msg, type = "info") {
        const el = document.createElement("div");
        el.className = type;
        el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        $('log').appendChild(el);
        $('log').scrollTop = $('log').scrollHeight;
    }

    window.addEventListener("error", (event) => {
        log("Global error: " + event.message, "error");
    });

    ws.onopen = () => log("WebSocket connected", "event");

    ws.onmessage = async ({ data }) => {
        try {
            const msg = JSON.parse(data);
            if (msg.type === 'init') {
                $('myId').textContent = msg.id;
                log("Received init with ID: " + msg.id, "event");
            }

            if (msg.type === 'answer') {
                log("Received answer from receiver", "event");
                await pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
                remoteDescriptionSet = true;
            }

            if (msg.type === 'candidate') {
                if (!msg.candidate || !msg.candidate.candidate) {
                    log("Ignoring invalid ICE candidate", "info");
                    return;
                }

                if (!remoteDescriptionSet) {
                    log("Skipping ICE candidate (remoteDescription not set yet)", "error");
                    return;
                }

                try {
                    await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
                    log("Added ICE candidate", "event");
                } catch (err) {
                    log("Error adding ICE candidate: " + err.message, "error");
                }
            }
        } catch (err) {
            log("Error in onmessage: " + err.message, "error");
        }
    };

    ws.onerror = err => log("WebSocket error: " + err.message, "error");

    pc.onicecandidate = ({ candidate }) => {
        if (candidate && remoteId) {
            ws.send(JSON.stringify({ to: remoteId, type: 'candidate', candidate }));
            log("Sent ICE candidate", "info");
        }
    };

    $('connect').onclick = async () => {
        remoteId = $('remoteId').value;
        if (!remoteId) return log("Receiver ID is required", "error");

        dataChannel = pc.createDataChannel("file");
        dataChannel.binaryType = 'arraybuffer';

        dataChannel.onopen = () => log("DataChannel opened", "event");

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        log("Created and sent offer", "info");
        ws.send(JSON.stringify({ to: remoteId, type: 'offer', offer }));
    };

    $('sendFile').onclick = () => {
        const file = $('fileInput').files[0];
        if (!file || !dataChannel || dataChannel.readyState !== "open") {
            return log("No file selected or DataChannel not open", "error");
        }

        const header = JSON.stringify({ name: file.name, size: file.size });
        dataChannel.send(header);
        log(`Sending file: ${file.name} (${file.size} bytes)`, "info");

        const reader = new FileReader();
        let offset = 0;

        const readSlice = o => {
            const slice = file.slice(o, o + CHUNK_SIZE);
            reader.readAsArrayBuffer(slice);
        };

        reader.onload = e => {
            dataChannel.send(e.target.result);
            offset += e.target.result.byteLength;
            log(`Sent chunk: ${offset}/${file.size}`, "info");

            if (offset < file.size) {
                setTimeout(() => readSlice(offset), 0);
            } else {
                log("File transfer complete", "event");
            }
        };

        reader.onerror = () => log("Error reading file", "error");

        readSlice(0);
    };
</script>
</body>
</html>
